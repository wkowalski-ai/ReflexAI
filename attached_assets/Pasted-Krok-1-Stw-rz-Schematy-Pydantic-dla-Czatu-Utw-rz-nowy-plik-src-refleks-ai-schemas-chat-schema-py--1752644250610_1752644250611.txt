Krok 1: Stwórz Schematy Pydantic dla Czatu

Utwórz nowy plik src/refleks_ai/schemas/chat_schema.py. Zdefiniuj w nim następujące schematy:

ChatMessage: z polami role (Literal["system", "user", "assistant"]) i content (str).

ChatRequest: z polem history (List[ChatMessage]).

ChatResponse: z polem message (ChatMessage).

Krok 2: Stwórz Serwis do Komunikacji z AI

Utwórz nowy plik src/refleks_ai/services/ai_service.py. Umieścimy w nim całą logikę związaną z komunikacją z zewnętrznym API.

Zdefiniuj w nim asynchroniczną funkcję get_ai_response(history: List[dict]) -> str:

Funkcja ta powinna odczytywać OPENROUTER_API_KEY ze zmiennych środowiskowych.

Używać biblioteki httpx, aby wysłać asynchroniczne żądanie POST na adres https://openrouter.ai/api/v1/chat/completions.

W ciele żądania (payload) umieść model: "google/gemini-flash-1.5" oraz messages: history.

W nagłówkach (headers) dodaj Authorization: Bearer {OPENROUTER_API_KEY}.

Funkcja ma sparsować odpowiedź i zwrócić treść wiadomości od asystenta.

Zdefiniuj drugą asynchroniczną funkcję summarize_session(history: List[dict]) -> dict:

Funkcja ta na końcu listy history dodaje nowy prompt systemowy, nakazujący AI podsumowanie rozmowy i zwrócenie wyniku wyłącznie w formacie JSON o strukturze: {"summary_title": "...", "session_data": {"situation": "...", "automatic_thought": "...", ...}}.

Wywołuje API OpenRouter w taki sam sposób jak get_ai_response.

Parsuje odpowiedź JSON od AI i zwraca ją jako słownik Pythona.

Krok 3: Stwórz Router do Obsługi Sesji Czatu

Utwórz nowy plik src/refleks_ai/routers/chat_router.py.

Zaimplementuj endpoint POST /chat/conversation, który:

Wymaga autentykacji (Depends(get_current_user)).

Przyjmuje w ciele żądania obiekt w schemacie ChatRequest.

Wywołuje serwis ai_service.get_ai_response, przekazując mu historię rozmowy.

Zwraca odpowiedź AI opakowaną w schemat ChatResponse.

Zaimplementuj endpoint POST /chat/end_session, który:

Wymaga autentykacji (Depends(get_current_user)).

Przyjmuje w ciele żądania finalną historię rozmowy (ChatRequest).

Wywołuje serwis ai_service.summarize_session, aby uzyskać ustrukturyzowane podsumowanie.

Zapisuje to podsumowanie w bazie danych jako nowy wpis ThoughtDiary, powiązany z zalogowanym użytkownikiem. (Wykorzystaj logikę z diary_router.py - możesz ją przenieść do wspólnego serwisu, aby uniknąć duplikacji kodu).

Zwraca nowo utworzony wpis z dziennika.

Krok 4: Zintegruj Nowy Router z Główną Aplikacją

W pliku src/refleks_ai/main.py zaimportuj i dołącz nowo utworzony chat_router do głównej aplikacji FastAPI.